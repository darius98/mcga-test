#include "mcga/test.hpp"

#include <array>
#include <iostream>
#include <thread>

#include <mcga/cli.hpp>

#include "core/box_executor.hpp"
#include "core/executor.hpp"
#include "core/export.hpp"
#include "core/main.hpp"
#include "extensions/feedback/ext.hpp"
#include "extensions/filter/ext.hpp"

using namespace mcga::cli;
using namespace mcga::test;

MCGA_TEST_EXPORT_WEAK int main(int argc, char** argv) {
    mcga::test::FeedbackExtension feedbackExtension;
    mcga::test::ExitCodeExtension exitCodeExtension;
    mcga::test::FilterExtension filterExtension;

    const auto extensions = std::array<Extension*, 3>{
      &feedbackExtension,
      &exitCodeExtension,
      &filterExtension,
    };

    Parser parser("Test binary. Generated by The MCGA::Test Framework.");

    parser.add_help_flag();
    auto executorTypeArg = parser.add_choice_argument(
      ChoiceArgumentSpec<Executor::Type>("executor")
        .set_description("Choose the type of executor to use. A smooth "
                         "executor runs all tests in the same process, "
                         "while a boxed executor runs each test in a "
                         "separate process. Using a smooth executor "
                         "means a test killed by signal will not be "
                         "detected and will kill the whole test suite.")
        .set_options({{"smooth", Executor::SMOOTH}, {"boxed", Executor::BOXED}})
        .set_default_value("boxed"));
    auto maxParallelTestsArg = parser.add_numeric_argument<size_t>(
      NumericArgumentSpec("max-parallel-tests")
        .set_description("Maximum number of tests to execute in parallel"
                         " (processes to spawn). Ignored if `executor` "
                         "type is 'smooth'.")
        .set_default_value("1")
        .set_implicit_value_generator(
          [] {
              return std::to_string(std::thread::hardware_concurrency());
          },
          "Number of CPUs ("
            + std::to_string(std::thread::hardware_concurrency()) + ")"));
    auto testRepeatMultiplierArg = parser.add_numeric_argument<int>(
      NumericArgumentSpec("repeat")
        .set_description("Repeat the tests multiple times.")
        .set_default_value("1"));

    for (const auto& extension: extensions) {
        extension->registerCommandLineArgs(&parser);
    }

    parser.parse(argc, argv);

    const auto options = EntryPointOptions{
      .extensions = extensions.data(),
      .numExtensions = extensions.size(),
      .numRuns = testRepeatMultiplierArg->get_value(),
    };

    switch (executorTypeArg->get_value()) {
        case Executor::SMOOTH: {
            SmoothExecutor executor;
            runTests(&executor, options);
            break;
        }
        case Executor::BOXED: {
            auto numBoxes = std::max(maxParallelTestsArg->get_value(), 1ul);
            BoxExecutor executor(numBoxes);
            runTests(&executor, options);
            break;
        }
        default: {
            std::cout << "Unknown executor type. Aborting.";
            return EXIT_FAILURE;
        }
    }

    return exitCodeExtension.getExitCode();
}
